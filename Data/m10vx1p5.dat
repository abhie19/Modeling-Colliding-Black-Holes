      program bhfind

c     Fit r(t) for black hole

      real e0fit
      real defit

      parameter(e0fit=0.0037821638)
      parameter(defit=0.0067252936)


      parameter (maxp=100000,maxm=2000,pi=3.141592)
      real    time,rnpairs,rbar,zmbar,rtide,tidal4,rdens(3),timetcr
      real    tscale,vstar,rc,rnc,vc,rhom,cmax,rscale,rsmin,dmin1
      real    body(maxp),x(3,maxp),v(3,maxp),dummy(20),cmrdot(3)
      integer ntot,model,nrun,nk,name(maxp)
      character outfile*22

      real t(maxm)
      integer nstep

      real mbh
      real xbh(maxm),ybh(maxm),zbh(maxm),rbh(maxm)
      real vxbh,vybh,vzbh,vbh(maxm)

      real ms(1:maxp)
      real xs(1:maxp),ys(1:maxp),zs(1:maxp),rs(1:maxp)
      real vxs(1:maxp),vys(1:maxp),vzs(1:maxp),vs(1:maxp)

c     Energy
      real kin
      real mp, ap, ppot
      parameter(mp=25000.0/25010.0)
      parameter(ap=0.59207815554951)
      real e(maxm),e0
c     Theory

      real et(maxm),At(maxm),t_rt(maxm),rt(maxm)
      real e0t

c     Fitting
      real A(maxm),r(maxm),t_r(maxm)
c     For rtsafe
      real rp,rap,tol
      parameter(tol=0.01)

c     Common
      real fgc_r,fgc_m,fgc_vr,fgc_vt,fgc_vp
      real fgc_theta,fgc_phi
      common / gcparam / fgc_r,fgc_m,fgc_vr,fgc_vt,fgc_vp
      real vr2,vt2,vp2
      real vtan(maxm),Lmom(maxm)

      external func

      nstep=0
      t_r=0.0


      open(unit=2,file='bhfit.dat',status='replace')

      open(3,file='OUT3',form='unformatted')
      rewind(3)
c     Sum 1 for maxm for now
      do l = 1, maxm
        read(3,end=100) ntot,model,nrun,nk
        read(3) time,rnpairs,rbar,zmbar,rtide,tidal4,(rdens(k),k=1,3),
     +         timetcr,tscale,vstar,rc,rnc,vc,rhom,cmax,rscale,rsmin,
     +         dmin1,(body(j),j=1,ntot),((x(k,j),k=1,3),j=1,ntot),
     +         ((v(k,j),k=1,3),j=1,ntot),(name(j),j=1,ntot)

         ns=0
         nbh=0
         nstep=nstep+1
         t(l)=time

         if (t(l).ge.612.0) then
           go to 100
         end if

         do 60 j=1,ntot
           if(name(j).eq.50001)then
             nbh=1
             mbh=body(j)
             xbh(l)=x(1,j)
             ybh(l)=x(2,j)
             zbh(l)=x(3,j)
             vxbh=v(1,j)
             vybh=v(2,j)
             vzbh=v(3,j)
             rbh(l)=sqrt(xbh(l)**2.0+ybh(l)**2.0+zbh(l)**2.0)
             vbh(l)=sqrt(vxbh**2.0+vybh**2.0+vzbh**2.0)
             kin=0.5*(vbh(l)**2.0)
             ppot=pot(rbh(l))
             e(l)=kin+ppot
             if(l.eq.1) then
               e0=e(l)
               e0t=-1.0*exp(e0fit)
             end if
             A(l)=sqrt((1.0/(e(l)/((-1.0)*mp)))**2.0-ap**2.0)
             et(l)=e0t*exp(defit*time)
             At(l)=sqrt((1.0/(et(l)/((-1.0)*mp)))**2.0-ap**2.0)

           else
             ns=ns+1
             ms(ns)=body(j)
             xs(ns)=x(1,j)
             ys(ns)=x(2,j)
             zs(ns)=x(3,j)
             vxs(ns)=v(1,j)
             vys(ns)=v(2,j)
             vzs(ns)=v(3,j)
             vs(ns)=sqrt(vxs(ns)**2.0+vys(ns)**2.0+vzs(ns)**2.0)
             rs(ns)=sqrt(xs(ns)**2.0+ys(ns)**2.0+zs(ns)**2.0)

           end if
 60      continue

c        Find radial period
         fgc_r=rbh(l)
         fgc_theta=ATAN(sqrt(xbh(l)**2.0+ybh(l)**2.0)/zbh(l))
         fgc_phi=ATAN(ybh(l)/xbh(l))
         fgc_m=mbh

         fgc_vr=vxbh*sin(fgc_theta)*cos(fgc_phi)+
     &vybh*sin(fgc_theta)*sin(fgc_phi)+vzbh*cos(fgc_theta)

         fgc_vt=vxbh*cos(fgc_theta)*cos(fgc_phi)+
     &vybh*cos(fgc_theta)*sin(fgc_phi)-vzbh*sin(fgc_theta)

         fgc_vp=-1.0*vxbh*sin(fgc_phi)+vybh*cos(fgc_phi)

         vtan(l)=sqrt(fgc_vt**2.0+fgc_vp**2.0)
         Lmom(l)=vtan(l)*fgc_r

c         rp=rtsafe(func,0.0001,fgc_r,tol)
c         rap=rtsafe(func,fgc_r,A(l),tol)
         rp=0.0
         rap=A(l)

         print *,rp,fgc_r,rap,rbh(l),fgc_r,fgc_theta,fgc_phi,
     &fgc_vr,fgc_vp,fgc_vt,vtan(l),Lmom(l),prad(fgc_r)

         call trapzd(prad,rp,rap,
     &t_r(l),20)

         t_r(l)=t_r(l)*2.0

c        Here t_r is the period to get from 0 to r and back
c        From SHM we want period to be 0 to r, r to 0, 0 to -r, and -r to 0
         t_r(l)=t_r(l)*2.0

c        Repeat for theory
         rp=0.0
         rap=At(l)

         call trapzd(prad,rp,rap,
     &t_rt(l),20)
         t_rt(l)=t_rt(l)*4.0

      end do
 100  continue
      close(3)

      call fitbh(t(1:nstep),rbh(1:nstep),
     &e0,A(1:nstep),t_r(1:nstep),nstep,r(1:nstep))

      call fitbh(t(1:nstep),rbh(1:nstep),
     &e0,At(1:nstep),t_rt(1:nstep),nstep,rt(1:nstep))

      do l=1,nstep

        write(2,*) t(l),rbh(l),e0,e(l),
     &LOG(-1.0*e(l)),Lmom(l),A(l),r(l),t_r(l),
     &rt(l),At(l),t_rt(l),et(l),vbh(l)

      end do

      close(2)

      end

      SUBROUTINE fitbh(time,rbh,e0,A,t_r,nstep,r)
      integer nstep
      real time(1:nstep),rbh(1:nstep),t_r(1:nstep)
      real r(1:nstep)
      real e0,A(1:nstep),w
      real df,chsq,prob
      real chsq_best,B_best

      chsq_best=10000000.0

c      do j=1,100

c        B=real(j)

c        do i=1,nstep
c          w=2.0*3.14159/t_r(i)
c          r(i)=A(i)*sin(w*time(i))
c        end do

c        call chstwo(rbh,r,
c     &nstep,0,df,chsq,prob)

c        print *,B,chsq

c        if (chsq.lt.chsq_best) B_best=B

c      end do

      do i=1,nstep
        w=2.0*3.14159/t_r(i)
        r(i)=A(i)*sin(w*time(i))
      end do

      r=sqrt(r**2.0)

      END SUBROUTINE


        SUBROUTINE sort(n,arr)
        INTEGER n,M,NSTACK
        REAL arr(n)
        PARAMETER (M=7,NSTACK=50)
        INTEGER i,ir,j,jstack,k,l,istack(NSTACK)
        REAL a,temp
        jstack=0
        l=1
        ir=n
1       if(ir-l.lt.M)then
          do 12 j=l+1,ir
            a=arr(j)
            do 11 i=j-1,1,-1
              if(arr(i).le.a)goto 2
              arr(i+1)=arr(i)
11          continue
            i=0
2           arr(i+1)=a
12        continue
          if(jstack.eq.0)return
          ir=istack(jstack)
          l=istack(jstack-1)
          jstack=jstack-2
        else
          k=(l+ir)/2
          temp=arr(k)
          arr(k)=arr(l+1)
          arr(l+1)=temp
          if(arr(l+1).gt.arr(ir))then
            temp=arr(l+1)
            arr(l+1)=arr(ir)
            arr(ir)=temp
          endif
          if(arr(l).gt.arr(ir))then
            temp=arr(l)
            arr(l)=arr(ir)
            arr(ir)=temp
          endif
          if(arr(l+1).gt.arr(l))then
            temp=arr(l+1)
            arr(l+1)=arr(l)
            arr(l)=temp
          endif
          i=l+1
          j=ir
          a=arr(l)
3         continue
            i=i+1
          if(arr(i).lt.a)goto 3
4         continue
            j=j-1
          if(arr(j).gt.a)goto 4
          if(j.lt.i)goto 5
          temp=arr(i)
          arr(i)=arr(j)
          arr(j)=temp
          goto 3
5         arr(l)=arr(j)
          arr(j)=a
          jstack=jstack+2
          if(jstack.gt.NSTACK)pause 'NSTACK too small in sort'
          if(ir-i+1.ge.j-l)then
            istack(jstack)=ir
            istack(jstack-1)=i
            ir=j-1
          else
            istack(jstack)=j-1
            istack(jstack-1)=l
            l=i
          endif
        endif
        goto 1
        END


      SUBROUTINE trapzd(func,a,b,s,n)
      INTEGER n
      REAL a,b,s,func
      EXTERNAL func
      INTEGER it,j
      REAL del,sum,tnm,x
      if (n.eq.1) then
        s=0.5*(b-a)*(func(a)+func(b))
      else
        it=2**(n-2)
        tnm=it
        del=(b-a)/tnm
        x=a+0.5*del
        sum=0.
        do 11 j=1,it
          sum=sum+func(x)
          x=x+del
11      continue
        s=0.5*(s+(b-a)*sum/tnm)
      endif
      return
      END

      FUNCTION pot(r)

      real m,a,r,pot,mbh
      m=25000.0/25010.0
      a=0.59207815554951

      pot=(-1.0)*m/sqrt(r**2.0+a**2.0)

      END

      FUNCTION dpot(r)

      real m,a,r,dpot,mbh
      m=25000.0/25010.0
      a=0.59207815554951

      dpot=r*m/((r**2.0+a**2.0)**(1.5))

      END

c ******************Radial Period*************************************

c The function prad(r) is equation 3:17 from Binney & Tremaine
c The integral of prad(r) gives the radial period of an orbit

      function prad(r)

      real Mcluster,vrcluster,vtcluster
      real E, L
      real prad,r
      common / gcparam / fgc_r,fgc_m,fgc_vr,fgc_vt,fgc_vp
      external pot

c     Read in Globular Cluster Parameters

      Mcluster=fgc_m
      vrcluster=fgc_vr
      vtcluster=((fgc_vt)**2.0+(fgc_vp)**2.0)**(0.5)

c     Set Orbital Parameters
     
      E=0.5*(vrcluster**2.0+vtcluster**2.0)+pot(fgc_r)
      
      L=fgc_r*vtcluster
      L=0.0
c      If fgc_rp is less then the true pericenter, Tr=0

	if ((2.0*(E-pot(r))-(L/r)**2.0) .gt. 0.0) then
            prad=1.0/sqrt(2.0*(E-pot(r))-(L/r)**2.0)
	else if ((2.0*(E-pot(r))-(L/r)**2.0) .le. 0.0) then
			prad=0.0
	end if

c        print *,'PRAD: ',fgc_vr,fgc_vt,fgc_vp,
c     &E,L,pot(fgc_r),r,fgc_r

      end


      SUBROUTINE chsone(bins,ebins,nbins,knstrn,df,chsq,prob)
      INTEGER knstrn,nbins
      REAL chsq,df,prob,bins(nbins),ebins(nbins)
CU    USES gammq
      INTEGER j
      REAL gammq
      df=nbins-knstrn
      chsq=0.
      do 11 j=1,nbins
        if(ebins(j).le.0.)pause 'bad expected number in chsone'
        chsq=chsq+(bins(j)-ebins(j))**2/ebins(j)
11    continue
      prob=gammq(0.5*df,0.5*chsq)
      return
      END

      SUBROUTINE chstwo(bins1,bins2,nbins,knstrn,df,chsq,prob)
      INTEGER knstrn,nbins
      REAL chsq,df,prob,bins1(nbins),bins2(nbins)
CU    USES gammq
      INTEGER j
      REAL gammq
      df=nbins-knstrn
      chsq=0.
      do 11 j=1,nbins
        if(bins1(j).eq.0..and.bins2(j).eq.0.)then
          df=df-1.
        else
          chsq=chsq+(bins1(j)-bins2(j))**2/(bins1(j)+bins2(j))
        endif
11    continue
      prob=gammq(0.5*df,0.5*chsq)
      return
      END

      FUNCTION gammq(a,x)
      REAL a,gammq,x
CU    USES gcf,gser
      REAL gammcf,gamser,gln
      if(x.lt.0..or.a.le.0.)pause 'bad arguments in gammq'
      if(x.lt.a+1.)then
        call gser(gamser,a,x,gln)
        gammq=1.-gamser
      else
        call gcf(gammcf,a,x,gln)
        gammq=gammcf
      endif
      return
      END

      SUBROUTINE gcf(gammcf,a,x,gln)
      INTEGER ITMAX
      REAL a,gammcf,gln,x,EPS,FPMIN
      PARAMETER (ITMAX=100,EPS=3.e-7,FPMIN=1.e-30)
CU    USES gammln
      INTEGER i
      REAL an,b,c,d,del,h,gammln
      gln=gammln(a)
      b=x+1.-a
      c=1./FPMIN
      d=1./b
      h=d
      do 11 i=1,ITMAX
        an=-i*(i-a)
        b=b+2.
        d=an*d+b
        if(abs(d).lt.FPMIN)d=FPMIN
        c=b+an/c
        if(abs(c).lt.FPMIN)c=FPMIN
        d=1./d
        del=d*c
        h=h*del
        if(abs(del-1.).lt.EPS)goto 1
11    continue
      pause 'a too large, ITMAX too small in gcf'
1     gammcf=exp(-x+a*log(x)-gln)*h
      return
      END

      SUBROUTINE gser(gamser,a,x,gln)
      INTEGER ITMAX
      REAL a,gamser,gln,x,EPS
      PARAMETER (ITMAX=100,EPS=3.e-7)
CU    USES gammln
      INTEGER n
      REAL ap,del,sum,gammln
      gln=gammln(a)
      if(x.le.0.)then
        if(x.lt.0.)pause 'x < 0 in gser'
        gamser=0.
        return
      endif
      ap=a
      sum=1./a
      del=sum
      do 11 n=1,ITMAX
        ap=ap+1.
        del=del*x/ap
        sum=sum+del
        if(abs(del).lt.abs(sum)*EPS)goto 1
11    continue
      pause 'a too large, ITMAX too small in gser'
1     gamser=sum*exp(-x+a*log(x)-gln)
      return
      END

      FUNCTION gammln(xx)
      REAL gammln,xx
      INTEGER j
      DOUBLE PRECISION ser,stp,tmp,x,y,cof(6)
      SAVE cof,stp
      DATA cof,stp/76.18009172947146d0,-86.50532032941677d0,
     *24.01409824083091d0,-1.231739572450155d0,.1208650973866179d-2,
     *-.5395239384953d-5,2.5066282746310005d0/
      x=xx
      y=x
      tmp=x+5.5d0
      tmp=(x+0.5d0)*log(tmp)-tmp
      ser=1.000000000190015d0
      do 11 j=1,6
        y=y+1.d0
        ser=ser+cof(j)/y
11    continue
      gammln=tmp+log(stp*ser/x)
      return
      END

c****************y & dy subroutine for rtsafe.f *************
c This function is for use by rtsafe to find the routes of
c Equation 3.14 in B&T, which is found in orbits.f

      subroutine func(x,f,df)

      real x,f,df

      f=y(x)
      df=dy(x)

      return

      end
c *******************EQUATION 3:14*************************************

c The function y(r) is equation 3:14 from Binney & Tremaine
c The roots of y(r) indicate the pericentric and apocentric radii of 
c the globular cluster

      function y(r)
      
      real Mcluster,Dcluster,vrcluster,vtcluster
      real E, L
      real root,r
      real y
      common / gcparam / fgc_r,fgc_m,fgc_vr,fgc_vt,fgc_vp

c     Read in Globular Cluster Parameters
      Mcluster=fgc_m
      Dcluster=fgc_r
      vrcluster=fgc_fr
      vtcluster=(fgc_vt**2.0+
     &fgc_vp**2.0)**(0.5)

c     Set Orbital Parameters
     
      E=0.5*(vrcluster**2.0+vtcluster**2.0)+
     &pot(fgc_r)

      L=Dcluster*vtcluster

      root=((1/(r))**2.0+
     &2.0*(pot(r)-E)/(L**2))
      root=root*10d30
      y=root

c      print *,'DEBUG in Y ','E= ',E,'and L= ',L,
c     &' and V =',V(rad),'y = ',root,rad

      
      end

c ************Derivative of Equation 3:14************************


c The function dy(r) is the derivative of equation 3:14 from Binney & Tremaine
c The roots of dy(r) indicate the pericentric and apocentric radii of 
c the globular cluster

      function dy(r)
      
      real Mcluster,Dcluster,vrcluster,vtcluster
      real E, L
      real droot,r
      real dy
      common / gcparam / fgc_r,fgc_m,fgc_vr,fgc_vt,fgc_vp

c     Set Globular Cluster Parameters
      Mcluster=fgc_m
      Dcluster=fgc_r
      vrcluster=fgc_vr
      vtcluster=(fgc_vt**2.0+
     &fgc_vp**2.0)**(0.5)

c     Set Orbital Parameters
           
      L=Dcluster*vtcluster

      droot=((-2/(r))**3.0+2.0*dpot(r)/(L**2))
      droot=droot*10d30
      dy=droot

c      print *,'DEBUG in DY ',L,dV(rad),droot,dy


      end
c*****************Root Finder w Derivatives*********************************
      FUNCTION rtsafe(funcd,x1,x2,xacc)
      INTEGER MAXIT
      REAL rtsafe,x1,x2,xacc
      EXTERNAL funcd
      PARAMETER (MAXIT=100)
      INTEGER j
      REAL df,dx,dxold,f,fh,fl,temp,xh,xl
      call funcd(x1,fl,df)
      call funcd(x2,fh,df)
c      if((fl.gt.0..and.fh.gt.0.).or.(fl.lt.0..and.fh.lt.0.))pause
c     &'root must be bracketed in rtsafe'
      if(fl.eq.0.)then
        rtsafe=x1
        return
      else if(fh.eq.0.)then
        rtsafe=x2
        return
      else if(fl.lt.0.)then
        xl=x1
        xh=x2
      else
        xh=x1
        xl=x2
      endif
      rtsafe=.5*(x1+x2)
      dxold=abs(x2-x1)
      dx=dxold
      call funcd(rtsafe,f,df)
      do 11 j=1,MAXIT
        if(((rtsafe-xh)*df-f)*((rtsafe-xl)*df-f).ge.0..or. abs(2.*
     *f).gt.abs(dxold*df) ) then
          dxold=dx
          dx=0.5*(xh-xl)
          rtsafe=xl+dx
          if(xl.eq.rtsafe)return
        else
          dxold=dx
          dx=f/df
          temp=rtsafe
          rtsafe=rtsafe-dx
          if(temp.eq.rtsafe)return
        endif
        if(abs(dx).lt.xacc) return
        call funcd(rtsafe,f,df)
        if(f.lt.0.) then
          xl=rtsafe
        else
          xh=rtsafe
        endif
11    continue
      pause 'rtsafe exceeding maximum iterations'
      return
      END
